#ifndef __PROG_SBW_JTAG_H_
#define __PROG_SBW_JTAG_H_

#include <stdint.h>

#define DRV_ERR_TIMEOUT -3
#define DRV_ERR_VERIFY -2
#define DRV_ERR_GENERIC -1
#define DRV_ERR_OK 0
#define DRV_ERR_PROTECTED 1

#define SC_ERR_GENERIC -1
#define SC_ERR_NONE 0
#define SC_ERR_ET_DCDC_IDCODE 2
#define SC_ERR_ET_DCDC_DEVID 3
#define SC_ERR_ET_DCDC_CPU_STATE 4
#define SC_ERR_ET_DCDC_FLASH_VERI 5
#define STATUS_FUSEBLOWN 6
#define STATUS_ACTIVE 7
#define STATUS_IDLE 8

#define STATUS_FUSEBLOWN 6
#define STATUS_ACTIVE 7
#define STATUS_IDLE 8

// Constants for data formats, dedicated addresses
#define F_BYTE 8
#define F_WORD 16
#define F_ADDR 20
#define F_LONG 32
#define F_LONG_LONG 64
#define V_RESET 0xFFFE
#define V_BOR 0x1B08

#define RSTLOW_SBW 0
#define RSTLOW_JTAG 1
#define RSTHIGH_SBW 2
#define RSTHIGH_JTAG 3

/**
 * Instructions for controlling the CPU
 * Set the JTAG control signal register
 *
 * original value: 0x13
 */
#define IR_CNTRL_SIG_16BIT 0xC8

/**
 * Instructions for controlling the CPU
 * Read out the JTAG control signal register
 *
 * original value: 0x14
 */
#define IR_CNTRL_SIG_CAPTURE 0x28

/**
 * Instructions for controlling the CPU
 * Release the CPU from JTAG control
 *
 * original value: 0x15
 */
#define IR_CNTRL_SIG_RELEASE 0xA8

/**
 * Instructions for the JTAG fuse
 * Prepare for JTAG fuse blow
 *
 * original value: 0x22
 */
#define IR_PREPARE_BLOW 0x44

/**
 * Instructions for the JTAG fuse
 * Perform JTAG fuse blow
 *
 * original value: 0x24
 */
#define IR_EX_BLOW 0x24

/**
 * Instructions for mailbox system
 * Request a JTAG mailbox exchange
 *
 * Original value: 0x61
 */
#define IR_JMB_EXCHANGE 0x86

/**
 * Instructions for the JTAG data register
 * Set the MSP430 MDB to a specific 16-bit value with the next 16-bit data access
 *
 * Original value: 0x41
 */
#define IR_DATA_16BIT 0x82

/**
 * Instructions for the JTAG data register
 * Set the MSP430 MDB to a specific 16-bit value (RAM only)
 *
 * Original value: 0x43
 */
#define IR_DATA_QUICK 0xC2

/**
 * Instructions for the JTAG data register
 * Set the MSP430 MDB with a specific 16-bit value and write it to the memory address which is currently on the MAB
 *
 * Original value: 0x85
 */
#define IR_DATA_TO_ADDR 0xA1

/**
 * Instructions for the JTAG data register
 * Bypass instruction - TDI input is shifted to TDO as an output
 *
 * Original value: 0xFF
 */
#define IR_BYPASS 0xFF

/**
 * Instructions for the JTAG data register
 * ??
 *
 * Original value: 0x42
 */
#define IR_DATA_CAPTURE 0x42

/**
 * Instructions for the JTAG PSA mode
 * Switch JTAG data register to PSA mode
 *
 * Original value: 0x44
 */
#define IR_DATA_PSA 0x22

/**
 * Instructions for the JTAG PSA mode
 * Shift out the PSA pattern generated by IR_DATA_PSA
 *
 * Original value: 0x46
 */
#define IR_SHIFT_OUT_PSA 0x62

/**
 * Instructions for the JTAG address register
 * Set the MSP430 MAB to a specific 16-bit value
 * Use the 20-bit macro for 430X and 430Xv2 architectures
 *
 * Original value: 0x83
 */
#define IR_ADDR_16BIT 0xC1

/**
 * Instructions for the JTAG address register
 * Read out the MAB data on the next 16/20-bit data access
 *
 * Original value: 0x84
 */
#define IR_ADDR_CAPTURE 0x21

/**
 * Instructions for the breakpoint logic
 * ??
 *
 * Original value: 0x09
 */
#define IR_BP_CNTL_16BIT 0x90

/**
 * Instructions for the breakpoint logic
 * ??
 *
 * Original value: 0x0A
 */
#define IR_BP_CNTL_CAPTURE 0x50

/**
 * Instructions for the breakpoint logic
 * ??
 *
 * Original value: 0x0B
 */
#define IR_BP1_16BIT 0xD0

/**
 * Instructions for the breakpoint logic
 * ??
 *
 * Original value: 0x0C
 */
#define IR_BP1_CAPTURE 0x30

/**
 * Instructions for the breakpoint logic
 * ?? 
 *
 * Original value: 0x0D
 */
#define IR_BP2_16BIT 0xB0

/**
 * Instructions for the breakpoint logic
 * ??
 *
 * Original value: 0x0E
 */
#define IR_BP2_CAPTURE 0x70

// Instructions to access the Emex registers
#define   IR_EMEX_DATA_EXCHANGE   0x90  // 09
#define   IR_EMEX_READ_TRIGGER    0x50  // 0A
#define   IR_EMEX_READ_CONTROL    0xD0  // 0B
#define   IR_EMEX_WRITE_CONTROL   0x30  // 0C
#define   IR_EMEX_DATA_EXCHANGE32 0xB0

#define IR_JSTATE_ID             0x46 // 62

// JTAG identification values for all existing Flash-based MSP430 devices
// JTAG identification value for 430X architecture devices
#define JTAG_ID 0x89
// JTAG identification value for 430Xv2 architecture devices
#define JTAG_ID91 0x91
// JTAG identification value for 430Xv2 architecture FR4XX/FR2xx devices
#define JTAG_ID98 0x98
// JTAG identification value for 430Xv2 architecture FR59XX devices
#define JTAG_ID99 0x99
// Additional instructions for JTAG_ID91 architectures
// Instruction to determine device's CoreIP
#define IR_COREIP_ID 0xE8  // original value: 0x17
// Instruction to determine device's DeviceID
#define IR_DEVICE_ID 0xE1  // original value: 0x87

// Instruction for test register in 5xx
#define IR_TEST_REG 0x54  // original value: 0x2A
// Instruction for 3 volt test register in 5xx
#define IR_TEST_3V_REG 0xF4  // original value: 0x2F

// JTAG mailbox constant -
#define OUT1RDY 0x0008
// JTAG mailbox constant -
#define IN0RDY 0x0001
// JTAG mailbox constant -
#define JMB32B 0x0010
// JTAG mailbox constant -
#define OUTREQ 0x0004
// JTAG mailbox constant -
#define INREQ 0x0001
// JTAG mailbox mode 32 bit -
#define MAIL_BOX_32BIT 0x10
// JTAG mailbox moede 16 bit -
#define MAIL_BOX_16BIT 0x00

// Breakpoint block
// EMEX address = BP number * Block size + Register offset + R/W offset
// Note: In Volker's new EEM documentation, this block is called the Memory Bus Trigger
#define MX_BLKSIZE             8      // Block size
#define MX_BP                0x0000 // Breakpoint value offset
#define MX_CNTRL             0x0002 // Control offset
#define MX_MASK                0x0004 // Mask offset
#define MX_COMB                0x0006 // Combination offset

#define MX_WRITE 0x0
#define MX_READ 0x1

#define   MX_EEMVER               0x0087
#define   MX_CPUSTOP              0x0080
#define   MX_GENCNTRL             0x0082
#define MX_GCLKCTRL               0x0088
#define MX_MCLKCNTL0              0x008A
#define MX_TRIGFLAG               0x008E

#define ERASE_MAIN 0xA506     // erase of the entire flash main memory
#define ERASE_BANK 0xA504     // erase of a single flash memory bank
#define ERASE_SEGMENT 0xA502  // erase of the selected flash memory segment
#define MAIN_ERASE 0x1A1A     // erase of the FRAM Main memory on FR5xx/FR6xx
#define TOTAL_ERASE 0x1B1B    // erase of the FRAM Main, INFO  & IP protected memory on FR5xx/FR6xx
/* Erase of the FRAM Main & INFO memory including JTAG lock signature on FR4xx */
#define USER_CODE_ERASE 0x1A1A
#define STOP_DEVICE 0xA55A

/**
 * Reads a 32bit value from the JTAG mailbox.
 *
 * @returns 32bit value from JTAG mailbox
 */
int i_ReadJmbOut(void);

/**
 * Writes a 16bit value into the JTAG mailbox system. The function timeouts if the mailbox is not
 * empty after a certain number of retries.
 *
 * @param dataX data to be shifted into mailbox
 */
int i_WriteJmbIn16(uint16_t dataX);

/**
 * Writes a 32bit value into the JTAG mailbox system. The function timeouts if the mailbox
 * is not empty after a certain number of retries.
 *
 * @param dataX data to be shifted into mailbox
 * @param dataY data to be shifted into mailbox
 *
 */
int i_WriteJmbIn32(uint16_t dataX, uint16_t dataY);

/* Loads a JTAG instruction into the JTAG instruction register (IR) of the target device */
uint32_t IR_Shift(uint8_t instruction);

/* Loads a 16-bit word into the JTAG data register */
uint16_t DR_Shift16(uint16_t data);

/* Loads a 20-bit word into the JTAG data register */
uint32_t DR_Shift20(uint32_t address);

/* Loads a 32-bit data into the JTAG data register */
uint32_t DR_Shift32(uint32_t address);

/* Loads a 64-bit data into the JTAG data register */
uint64_t DR_Shift64(uint64_t address);

/* Connect the JTAG/SBW Signals and execute delay */
void ConnectJTAG(void);

/* Stop JTAG/SBW by disabling the pins and executing delay */
void StopJtag(void);

/**
 * Applies the sequence to enter SBW mode with reset pin set high. Device starts
 * executing code.
 */
void EntrySequences_RstHigh_SBW(void);
/* Applies the sequence to enter SBW mode with reset pin set low. Device halts. */
void EntrySequences_RstLow_SBW(void);

/* Resets the TAP controller state machine */
void ResetTAP(void);

/**
 * Enables JTAG communication with a target. Use JSBW mode if device is in LPM5 mode.
 *
 * @returns JTAG_ID91(0x91) if connection was established successfully, invalid JTAG ID (0x1) otherwise)
 */
uint16_t magicPattern(void);

/**
 *  Checks if the JTAG lock key is programmed.
 *
 * @returns SC_ERR_NONE if device is unlocked, SC_ERR_GENERIC if locked
 */
int IsLockKeyProgrammed(void);

#endif /* __PROG_SBW_JTAG_H_ */
